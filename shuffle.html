<!doctype html>
<style type="text/css">
	body { text-align:center; }
	.card { display:inline-block; text-align:center; width:150px; height:200px; }
	.card.text { box-shadow:0 0 1px black; }
	.controls { margin:1em; }

	.card big { font-size:5em; }
	.card med { font-size:1.5em; }
	.card sml { font-size:0.7em; }

	#explanation { text-align:left; line-height:140%; max-width:500px; margin:0 auto; }
	#explanation q { background:#eee; border:1px solid #999; border-radius:3px;
				   padding:0 2px; font-family:sans-serif; font-size:90%; }
	#explanation q::before, #explanation q::after {content:"";}
		
	.info { margin:1em auto; font-size:20px; white-space:break-spaces;
		  box-shadow:0 0; width:100%; text-align:center; }
	.info:focus { outline:1px solid grey; }

	.row { display:flex; }
	.row .deck, .row .note { flex:1; margin:0; }

	textarea { outline:0; border:0.5em solid white; box-shadow:0 0 0 1px black; margin:1px; }
	
	#drawn { line-height:0; margin:1em; }
	#drawn .card { margin:5px; line-height:normal; }
	#drawn .card.text { position:relative; background-color:white; color:black; }
	#drawn .card.text .content { position:absolute; top:50%; transform:translateY(-50%); left:5px; right:5px; max-height:100%; pointer-events:none; }

	.deck + .deck, .deck + .info { margin-left:1em; }
	.deck #actions { width:100%; overflow-x:auto; white-space:nowrap; }
	
	#shuffled { display:none; zoom:0.5; }
	#discarded { display:none; zoom:0.5; }

	#play_controls { display:none; }
	
	h1 { margin:1em; font-size:200%; font-weight:bold; margin:0; }

	
	#src_input { white-space:nowrap; }

	#prototype { display:none; }

	body .play_mode { display:none; }
	body.is-playing .edit_mode { display:none; }
	body.is-playing .play_mode { display:initial; }

	.deck { outline:0; }
	.deck:focus h1, .deck:has(button:focus) h1
		{ text-decoration:underline; }
	
</style>

<div id="prototype">
	<span class="card"></span>
	<div class="deck" tabindex="0">
		<h1 id="name_display"></h1>
		<div id="status_display"></div>

		<div id="actions">
			<button id="draw_button" title="Draw 1 card. Press 1-9 to draw that many cards.">Draw</button>
			<button id="draw_all_button">Draw All</button>
			<button id="roll_button" title="Shuffle all & draw 1 card">Roll</button>
			<button id="discard_button" title="Discard all drawn cards. Press 0.">Discard</button>
			<button id="shuffle_button" title="Shuffles all drawn and discards into the deck. Press S.">Shuffle</button>
		</div>
			
		<div id="drawn"></div>
	
		<div id="shuffled"></div>
		<div id="discarded"></div>
	</div>
</div>


<h1 class="edit_mode">Shuffle</h1>

<div>
	<label for="bg_brightness">BG:</label>
	<input id="bg_brightness" title="Background brightness"
		style="position:relative; top:3px;"
		type="range" min="0" max="100" value="100" steps="100" />
	<button class="play_mode" onclick="show_src(true)" id="edit_button">Edit</button>
</div>

<div class="play_mode">
	<div id="decks_shown"></div>
</div>
<div class="edit_mode">
	<textarea id="src_input" rows=10 cols=50></textarea>
	<br/><button id="play_button">Play</button><hr/>
	<input id="local_images" type="file" accept="image/*" multiple />
	<button onclick="local_images.value='';" title="Clear files">x</button>
	<br/><em>Select files to use with "local:" decks.<br/>
		Clear and re-select to reload changed images.</em>
</div>


<!--
#Die
px: 100x100
font:90px Arial
zoom:2
1x 1
1x 2
1x 3
1x 4
1x 5
1x 6
state: -|*|-
-->
<!--
# Helvetica Playing Cards
http://3.bp.blogspot.com/_w_0zEaXF8y8/TT3-sC0g6KI/AAAAAAAAAC0/ff4xXts7bfw/s1600/grid.jpg
grid: 8x7
margin: 38
zoom: 1.2
x0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
-->

<!--
# Aces
http://127.0.0.1:8887/English_pattern_playing_cards_deck.svg.png
grid:13x4
x1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0
state:|0 1 2 3|

# 2s
http://127.0.0.1:8887/English_pattern_playing_cards_deck.svg.png
grid:13x4
x0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0
state:|0 1 2 3|
-->
		
<!--
# TOT: Letters Setup
https://i.imgur.com/YMqN1nf.jpg
grid:1x13
zoom:0.3

# TOT: Sights Setup
https://i.imgur.com/DfBm3o1.png
grid:5x1
zoom:0.3

# TOT: Terrain
https://i.imgur.com/CVdaynk.png
grid:5x1
zoom:0.3
x6 2 7 4 8
-->


<style id="card_style" type="text/css"></style>
<script>
	var prototype = document.getElementById("prototype");
	prototype.parentNode.removeChild(prototype);
	prototype.id = "";

	function to_number(str) { return +str; }
	var find_integers = /\d+/g;
	
	var errors = [];
	function error(message) {
		errors.push(message);
		console.error(message);
	}
	var errors_reported = false;
	errors.report = function() {
		if (errors_reported) { return true; }
		
		if (errors.length > 0) {
			alert("Could not create deck(s) for the following reasons:\n\n"
				  + errors.join("\n"));
			errors_reported = true;
			return true;
		}
	}

	var adding_x_y = {};
	function index_to_x_y(deck, index, out) {
		out.x = (index % deck.gwidth);
		out.y = Math.floor((index - out.x) / deck.gwidth);
		return out;
	}

	function indices_of(nodes) {
		return [...nodes].map(function(c) { return c.dataset.index; });
	}

	var decks = [], deck;
	var decks_row;

	function show_src(editing) {
		if (!editing) {
			document.body.classList.add("is-playing");
		}
		else {
			document.body.classList.remove("is-playing");
		}
	}
	show_src(true);

	function generate_state(deck) {
		var shuffled = deck.shuffled.childNodes.length,
			drawn = deck.drawn.childNodes.length,
			discarded = deck.discarded.childNodes.length;

		if (drawn || discarded) {
			var shuffled_state;
			if (!shuffled) { shuffled_state = "-"; }
			// else if (!drawn && !discarded) { shuffled_state = "*"; }
			else if (shuffled < discarded) {
				shuffled_state = indices_of(deck.shuffled.childNodes).join(" ");
			}
			else { shuffled_state = "?"; }

			var drawn_state;
			if (!drawn) { drawn_state = "-"; }
			else if (!shuffled && !discarded) { drawn_state = "*"; }
			else {
				drawn_state = indices_of(deck.drawn.childNodes).join(" ");
			}

			var discarded_state;
			if (!discarded) { discarded_state = "-"; }
			else if (!shuffled && !drawn) { discarded_state = "*"; }
			else if (discarded <= shuffled) {
				discarded_state = indices_of(deck.discarded.childNodes).join(" ");
			}
			else { discarded_state = "?"; }

			return `\nstate: ${shuffled_state}|${drawn_state}|${discarded_state}`;
		}
		else {
			return "";
		}
	}

	function regen_text_cards(cards) {
		var f = undefined;
		var out = "";
		for (var i = 0; i < cards.length; i++) {
			if (f != cards[i].font) {
				f = cards[i].font;
				out += "\nfont:" + f;
			}
			out += `\n${cards[i].quantity}x ${cards[i].content}`
		}
		return out;
	}
	
	edit_button.onclick = function() {
		src_input.value = decks.map(function(deck) {
			if (deck.info) {
				return "." + (deck.side ? "<" : "") + " " + deck.html.value.replace(/\r?\n/g, "\\n");
			}
			else {
				return (
`#${deck.side ? "<" : ""} ${deck.name}${
	deck.local ? "\nlocal: "+deck.local
	: deck.img_url ? "\n" + deck.img_url
	: ""
}${
	deck.grid ? "\ngrid: " + deck.grid
		: deck.px ? "\npx: " + deck.px
		: ""
}${
	deck.zoom !== 1 ? "\nzoom: " + deck.zoom : ""
}${
	(deck.margin.x || deck.margin.y)
		? "\nmargin: " + (
			deck.margin.x === deck.margin.y
				? deck.margin.x
				: deck.margin.x + " " + deck.margin.y
		)
		: ""
}${
	deck.quantities ? "\nx" + deck.quantities.join(" ") : "" 
}${
	deck.text_cards ? regen_text_cards(deck.text_cards) : ""
}${
	generate_state(deck.shown)
}`
				);
			}
		}).join("\n\n");

		show_src(true);
	};

	bg_brightness.oninput = function() {
		document.body.style.backgroundColor = `rgba(0,0,0,${100 - (bg_brightness.value)}%)`;
		document.body.style.color = (bg_brightness.value > 50) ? "black" : "white";
		console.log(bg_brightness.value, document.body.style.backgroundColor);
	};
				
	play_button.onclick = function() {
		errors_reported = false;
		errors.length = 0;
		decks.length = 0; deck = null;
		loading_images = {};
		loading_promises.length = 0;
		decks_shown.innerHTML = "";

		var local_images_by_name = {};
		if (local_images.files.length > 0) {
			for (var i = 0; i < local_images.files.length; i++) {
				local_images_by_name[local_images.files[i].name] = local_images.files[i];
			}
		}
		
		src_input.value.replace(scan_src, parse_src);
		if (decks.length === 0) { error("Found no decks."); }
		if (errors.report()) { return; }

		// load images, setup decks
		Promise.all(
			decks.map(function(deck) {
				if (deck.img_url) {
					return new Promise(function(resolve, reject) {
						var img = deck.img = new Image();
						img.onload = resolve;
						img.onerror = function() {
							error(`Could not load image "${deck.img_url}".`);
							reject();
						};
						img.src = deck.img_url;
					});
				}
				else if (deck.local) {
					var deck_local_file = local_images_by_name[deck.local];
					if (deck_local_file) {
						return new Promise(function(resolve, reject) {
							var FR = new FileReader();
							FR.onload = function() {
								deck.img_url = URL.createObjectURL(new Blob([FR.result]),
									{ type: deck_local_file.type });
								deck.img = new Image();
								deck.img.onload = resolve;
								deck.img.src = deck.img_url;
							};
							FR.onerror = function() {
								error(`Could not load local image "${deck_local_file.name}".`);
								reject();
							};
							FR.readAsArrayBuffer(deck_local_file);
						});
					}
					else {
						error(`Local image "${deck.local}" not selected.`);
					}
				}
				else if (!deck.info && !deck.text_cards) {
					error(`No image or text cards defined for deck "${deck.name}".`);
				}
			})
		).then(function then() {
			decks.forEach(setup_deck);
			if (errors.report()) { return; }
			
			show_src(false);
		}, function do_catch() {
			errors.report();
		});
	};

	var loading_images;
	var loading_promises = [];
	
	var scan_src = /^\#(<)?[ \t]*(\S.*)$|^x((?:\d+[ \t]*)+)$|^((?:file|https?):.+)$|^(\d+)x[ \t]+(.+)$|^\.(<)?[ \t]*(.+)$|^(\w+):[ \t]*(.+)$/gm;
	function parse_src(m,
		deck_side, name,
		quantities, url,
		text_quantity, text,
		info_side, info,
		key, value
	) {
		if (errors.length > 0) { return; }

		if (!deck) {
			if (deck_side) { error("Deck to the side, but no non-side before it."); return; }
			if (info_side) { error("Info to the side, but no non-side before it."); return; }
		}
		if (name) {
			if (deck && !deck.info && !deck.img_url && !deck.text_cards) {
				error("No image defined for deck.");
				return;
			}
			decks.push(deck = { name: name });
			deck.side = deck_side;
		}
		else if (info) {
			decks.push(deck = { info: info });
			deck.side = info_side;
		}
		else {
			if (!deck) { error(`No name for deck when finding "${m}".`); return; }
			
			if (url) {
				deck.img_url = url;
			}
			else if (quantities) {
				deck.quantities = quantities;
			}
			else if (text_quantity) {
				var q = parseInt(text_quantity);
				if (text) {
					if (!deck.text_cards) { deck.text_cards = []; }
					deck.text_cards.push({ quantity:q, font:deck.font, content:text });
				}
				else {
					error(`Text card has no content.`);
					return;
				}
			}
			else if (key) {
				deck[key] = value;
			}
		}
	}


	function setup_deck(deck) {
		if (!deck.side) {
			decks_row = decks_shown.appendChild(document.createElement("div"));
			decks_row.className = "row";
		}

		
		if (deck.info) { // info
			var info = decks_row.appendChild(document.createElement("textarea"));
			info.className = "info";
			info.innerHTML = deck.info.replace(/\\n/g, "\n");
			deck.html = info;
			return;
		}

		
		if (errors.report()) { return; }
		
		if (!("zoom" in deck)) { deck.zoom = 1; }
		else { deck.zoom = +deck.zoom; }

		if (!("margin" in deck)) { deck.margin = { x:0, y:0 }; }
		else {
			var m = deck.margin.match(/^(\d+)(?:[ \t]+(\d+))?$/);
			if (!m) {
				error(`Invalid margin: "${deck.margin}".`);
				return;
			}
			else {
				if (m[2]) {
					deck.margin = { x:+m[1], y:+m[2] };
				}
				else {
					deck.margin = { x:+m[1], y:+m[1] };
				}
			}
		}
		
		var p = prototype.cloneNode(true);
		var card = deck.card_prototype = p.children[0];
		var deck_shown = deck.deck_shown = p.children[1];
		deck.shown = deck_shown;

		var shuffled = deck_shown.shuffled =
			deck_shown.querySelector("#shuffled");
		var shuffled_cards = shuffled.childNodes;
		
		var drawn = deck_shown.drawn =
			deck_shown.querySelector("#drawn");
		var drawn_cards = drawn.childNodes;
		
		var discarded = deck_shown.discarded =
			deck_shown.querySelector("#discarded");
		var discarded_cards = discarded.childNodes;


		deck_shown.draw_button = deck_shown.querySelector("#draw_button");
		deck_shown.draw_all_button = deck_shown.querySelector("#draw_all_button");
		deck_shown.roll_button = deck_shown.querySelector("#roll_button");
		deck_shown.discard_button = deck_shown.querySelector("#discard_button");
		deck_shown.shuffle_button = deck_shown.querySelector("#shuffle_button");
	
		deck_shown.status_display = deck_shown.querySelector("#status_display");

		
		var status = deck_shown.querySelector("#status_display");
		
		deck_shown.querySelector("#name_display").innerText = deck.name;

		if (deck.img) {
			var iwidth = deck.img.width - (deck.margin.x * 2);
			var iheight = deck.img.height - (deck.margin.y * 2);
		}
		
		if (deck.px) {
			var wh = deck.px.split("x").map(to_number);
			deck.cwidth = wh[0]; deck.cheight = wh[1];
			deck.gwidth = Math.round(iwidth/wh[0]) * wh[0];
			deck.gheight = Math.round(iheight/wh[1]) * wh[1];
		}
		else if (deck.grid) {
			var wh = deck.grid.split("x").map(to_number);
			deck.cwidth = iwidth/wh[0]; deck.cheight = iheight/wh[1];
			deck.gwidth = wh[0]; deck.gheight = wh[1];
		}
		else {
			deck.cwidth = iwidth;
			deck.cheight = iheight;
			deck.gwidth = 1; deck.gheight = 1;
		}
		
		// css
		// card.style.lineHeight = deck.cheight + "px";

		card.style.zoom = deck.zoom;
	
		if (deck.text_cards) {
			card.style.width = deck.cwidth + "px";
			card.style.height = deck.cheight + "px";
		}
		else {
			card.style.width = deck.cwidth + "px";
			card.style.height = deck.cheight + "px";
		}
		
		if (deck.img_url) {
			card.style.backgroundImage = `url("${deck.img_url}")`;
		}
		
		deck_shown.drawn.style.minHeight = (deck.cheight * deck.zoom) + "px";

	
		// add cards to shuffled deck
		var q, use_last = false;
		if (!deck.quantities) { q = 1; use_last = true; }
		else {
			deck.quantities = deck.quantities.split(" ").map(to_number);
		}

		
		var i = 0;
		if (deck.img) {
			for (; i < deck.gwidth * deck.gheight; i++) {
				if (!use_last) {
					if (i >= deck.quantities.length) {
						use_last = true;
						q = deck.quantities[deck.quantities.length - 1];
					}
					else {
						q = deck.quantities[i];
					}
				}
	
				if (q > 0) {
					var xy = index_to_x_y(deck, i, adding_x_y);
					var c = deck.card_prototype.cloneNode(true);
					c.dataset.index = i;
					
					c.style.backgroundPosition =
						`${(-deck.margin.x + (-xy.x * deck.cwidth))}px
						 ${(-deck.margin.y + (-xy.y * deck.cheight))}px`;
	
					shuffled.appendChild(c);
					
					for (var j = 1; j < q; j++) {
						shuffled.appendChild(c.cloneNode(true));
					}
				}
			}
		}


		// text cards
		if (deck.text_cards) {
			var offset = i;
			card.style.backgroundImage = "";
			card.className = "card text";
			for (i = 0; i < deck.text_cards.length; i++) {
				var t = deck.text_cards[i];
				var q = t.quantity;
	
				if (q > 0) {
					var c = card.cloneNode(true);
					var content = c.appendChild(document.createElement("div"));
					content.className = "content";
					content.innerHTML = t.content;

					c.dataset.index = offset + i;
					c.style.font = t.font;

					shuffled.appendChild(c);
				
					for (var j = 1; j < q; j++) {
						shuffled.appendChild(c.cloneNode(true));
					}
				}
			}
		}


		// restore state
		if (deck.state) {
			// debugger;
			var s = deck.state.split("|");

			// discarded has the rest?
			if (s[2] === "?") {
				move_all(shuffled, discarded);
			}
				
			switch(s[0]) { // shuffled state
				case "*": case "?": case "-": break;
				default: 
					move_all(shuffled, discarded);
					move_all_indices(s[0].match(find_integers), discarded, shuffled);
			}

			switch(s[1]) { // drawn state
				case "?": case "-": break;
				case "*": move_all(shuffled, drawn); break;
				default:
					// from deck_shown (from any pile)
					move_all_indices(s[1].match(find_integers), deck_shown, drawn);
			}

			switch(s[2]) { // discarded state
				case "?": case "-": break;
				case "*": move_all(shuffled, discarded); break;
				default:
					move_all_indices(s[2].match(find_integers), shuffled, discarded);
			}
		}

	
		// click handler
		deck_shown.addEventListener("click", function(e) {
			e.preventDefault();
			e.stopPropagation();

			// deck_shown.focus();

			if (e.target.classList.contains("card")) {
				discarded.prepend(e.target);
			}
			else { // buttons
				switch(e.target.id) {
					case "draw_button":
						drawn.appendChild(shuffled_cards[shuffled_cards.length * Math.random() | 0]);
						break;

					case "draw_all_button":
						move_all(shuffled, drawn);
						break;

					case "roll_button":
						deck_shown.shuffle_button.click();
						deck_shown.draw_button.click();
						break;

					case "discard_button":
						move_all(drawn, discarded);
						break;
					
					case "shuffle_button":
						move_all(discarded, shuffled);
						move_all(drawn, shuffled);
						break;
				}
			}
			
			update_controls(deck_shown);
		}, true);

		deck_shown.addEventListener("keyup", function(e) {
			if (e.shiftKey || e.ctrlKey) { return; }
			
			e.preventDefault();
			e.stopPropagation();
			
			switch(e.key) {
				case "1": case "2": case "3": case "4": case "5":
				case "6": case "7": case "8": case "9":
					for (var i = 0; i < +e.key; i++) {
						deck_shown.draw_button.click();
					}
					break;

				case "0":
					deck_shown.discard_button.click();
					break;

				case "s":
					deck_shown.shuffle_button.click();
					break;

				case "r":
					deck_shown.roll_button.click();
					break;
			}
		});

		update_controls(deck_shown);

		decks_row.appendChild(deck_shown);
	}

	function move_all(from, to) {
		while (from.childNodes.length > 0) {
			to.appendChild(from.childNodes[0]);
		}
	}
	function move_all_indices(indices, from, to) {
		for (var i = 0; i < indices.length; i++) {
			var c = from.querySelector(`.card[data-index="${indices[i]}"]`);
			if (c) { to.appendChild(c); }
			else { console.error(`Could not find card with index ${indices[i]}`); }
		}
	}



	function update_controls(deck_shown) {
		deck_shown.draw_button.disabled =
		deck_shown.draw_all_button.disabled =
			(deck_shown.shuffled.childNodes.length === 0);
		
		deck_shown.discard_button.disabled = 
			(deck_shown.drawn.childNodes.length === 0);

		deck_shown.shuffle_button.disabled = 
			(deck_shown.drawn.childNodes.length === 0
			&& deck_shown.discarded.childNodes.length === 0);

		deck_shown.status_display.innerText =
			`${deck_shown.shuffled.childNodes.length} shuffled | ${
				deck_shown.drawn.childNodes.length} drawn | ${
				deck_shown.discarded.childNodes.length} discarded`;
	}
	
</script>

<div class="edit_mode" id="explanation">
	<p>Type text into the source box above, 
		and click "Play" to load it.
		Drag the bottom-right corner of the box to adjust its size.
	</p>
	<p>Drag the BG slider at the top of the page
		to adjust how dark/light the page background is.
		This can help to avoid burnout in your screen if the page
		doesn't change for some time.
	</p>
	<p>
		While playing, click "Edit" to return to the source box.
		It will have "state" lines added to the decks to save which cards 
		are where, and notes will reflect any edited text.
		The source can be saved in a text file or message to save the current state, 
		and pasted in to resume playing from that state.
		The source text works as follows:
	</p>
	<p><q>. Notes</q>: An editable note that is displayed 
		between decks.
		While playing, notes can be edited during the game,
		and new lines can be added.
		Drag the bottom-right corner of the note to adjust its size.
	</p>
	<p><q># Name</q>: the name for the deck.
		<q>#&lt; Name</q> will place the deck on the same line as the 
		previous deck or note.
	</p>
	<p><q>http:...</q>, <q>https:...</q>:
		the address of an image to be used for the deck.
		<q>local:...</q> the file name of an image,
		to be selected with the file input below the source box.
		Click the "x" button next to the file input
		to clear it--allowing the images to be reloaded.
	</p>
	<p><q>grid:5x4</q>: how many cards across and how many cards down
		are in the image.
		Or <q>px:200x300</q>: the size in pixels of each card.
		If left out, the entire image will be used as one card.
	</p>
	<p><q>margin:5</q>: the margin to cut out around the entire image.
		Or <q>margin:5 10</q>: the margin for left/right, 
		and then the margin for top/bottom.
	</p>
	<p><q>zoom:1.2</q>: make the cards larger (> 1), or smaller (< 1).
	</p>
	<p><q>font:20px Arial</q>: the font to use for subsequent text cards
		within this deck.
		<em>Note, must include at least the font name.</em>
		See <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font" target="_blank">MDN reference</a> 
		for more details on how to write fonts.
	</p>
	<p><q>x1 2 0 1 1 19 0</q>: the quanitity of each card from the image,
		going top-to-bottom, left-to-right.
		<em>When left out, all cards will be included once.</em>
		If there are more cards in the image that quantities in the list,
		the last quantity will be used for the rest of the cards.
	</p>
	<p>
		<q>5x Card text</q>: a text card--starting with the quantity,
		and followed by the contents of the card.
		The cards will have a white background and black text.
		Text cards are added <em>after</em> image cards.
		This can include any text, emojis.
		<em>Search <a href="https://symbl.cc/" target="_blank">Symbl</a> 
		or <a href="https://emojidb.org/" target="_blank">EmojiDB</a>
		to find emoji to use for your cards.</em>
	</p>
	<p>These can also include HTML tags.
		Here are a few useful tags, but any tags should work.</p>
	<ul>
		<li><q>&lt;br/></q>: new line.</li>
		<li><q>&lt;hr/></q>: horizontal line, good for a border.</li>
		<li><q>&lt;b>text&lt;/b></q>: bold text.</li>
		<li><q>&lt;i>text&lt;/i></q>: italic text.</li>
		<li><q>&lt;u>text&lt;/u></q>: underlined text.</li>
		<li><q>&lt;big>text&lt;/big></q>: extra large, useful for single-icon cards.</li>
		<li><q>&lt;med>text&lt;/med></q>: slightly larger than normal text,
			useful for making an emoji slightly bigger to match the text,
			or headings.</li>
		<li><q>&lt;sml>text&lt;/sml></q>: smaller text.</li>
	</ul>
	<p><q>state:0 3|?|1 2 4</q>: which cards are in the shuffled deck,
		being shown, and discarded.
		<q>-</q> means no cards are here.
		<q>?</q> means the cards that are not elsewhere are here.
		<q>*</q> means all cards are here.
		<em>You don't have to worry about how this works unless
		you want to write it manually.</em>
	</p>
</div>
