<!doctype html>
<html>
<title>Shuffle | virtual card decks for flip n' write board games</title>
<body>
<style type="text/css">
	#status_display { 
		display:none; color:black;
		background:#eee; border:solid #999;
		border-width:1px 1px 0 0;
		border-top-right-radius:5px;
		padding:5px 7px;
		font-family:monospace;
		position:fixed; bottom:0; left:0;
	}
	#status_display.shown { display:block; }
	
	body { text-align:center; }
	.card { display:inline-block; text-align:center; width:150px; height:210px; }
	.card.text { box-shadow:0 0 1px black; }
	.controls { margin:1em; }

	body.dark, body.dark .info { color:white; }
	
	.card big { font-size:5em; }
	.card med { font-size:1.5em; }
	.card sml { font-size:0.7em; }

	#explanation { text-align:left; line-height:140%; max-width:500px; margin:0 auto; }
	#explanation q { background:#eee; border:1px solid #999; border-radius:3px;
				   padding:0 2px; font-family:monospace; }
	#explanation q::before, #explanation q::after {content:"";}
		
	.info { margin:1em auto; font-size:20px; white-space:break-spaces;
		  box-shadow:0 0; width:100%; text-align:center; 
		  background:transparent; border:none;
		   outline:0px solid grey;
		  }
	.info:focus { outline-width:1px; }

	.row { display:flex; margin:0.5em 0; }
	.row .deck, .row .info { flex:1; margin:0; }

	#src_input { outline:0; border:0.5em solid white; box-shadow:0 0 0 1px black; 
		margin:1px; white-space:nowrap;
	}
	
	#drawn { line-height:0; margin:1em; }
	#drawn .card {  line-height:normal; }
	#drawn .card.text { position:relative; background-color:white; color:black; }
	#drawn .card.text > .content { position:absolute; top:50%; transform:translateY(-50%); left:5px; right:5px; max-height:100%; pointer-events:none; }

	.deck + .deck, .deck + .info { margin-left:1em; }

	#shuffled { display:none; zoom:0.5; }
	#discarded { display:none; zoom:0.5; }

	#play_controls { display:none; }
	
	h1 { margin:1em; font-size:200%; font-weight:bold; margin:0; }

	#prototype { display:none; }

	body .play_mode { display:none; }
	body.is-playing .edit_mode { display:none; }
	body.is-playing .play_mode { display:initial; }

	body.is-playing .card { user-select:none; }

	body .from_edit { display:none; }
	body.edited .fresh { display:none; }
	body.edited .from_edit { display:initial; }
	
	.deck { outline:0; }
	.deck header { border-bottom:1px solid transparent; padding:4px 4px 3px 4px; }
	.deck header br { clear:both; }
	#name_display {
		float:left; display:inline; font-size:100%; margin-right:10px; 
/* 		padding:5px 0 0 5px; */
	}
	.deck:focus header, .deck:has(button:focus) header
		{ border-bottom-color:black; background-color:#eee; }
	body.dark .deck:focus header, body.dark .deck:has(button:focus) header
		{ border-bottom-color:white; background-color:#333; }


		.deck #actions { overflow-x:auto; white-space:nowrap; }

	#actions { float:right; display:inline-block; }
	#actions button { line-height:16px; }

</style>
<style id="card_styles_css"></style>

<div id="status_display">Test</div>

<div id="prototype">
	<span class="card" title="Click to discard"></span>
	<div class="deck" tabindex="0">
		<header>
			<h1 id="name_display"></h1>
			<div id="actions">
				<button id="draw_button" title="Draw 1 card. Press 1-9 to draw that many cards.">üé¥</button>
				<button id="draw_all_button" title="Draw All">‚ôæÔ∏è</button>
				<button id="roll_button" title="Shuffle all &amp; draw 1 card. Press R.">üé≤</button>
				<button id="discard_button" title="Discard all drawn cards. Press 0.">üóëÔ∏è</button>
				<button id="undiscard_button" title="Undiscard, draws the last-discarded card.">‚¨Ö</button>
				<button id="shuffle_button" title="Shuffles all drawn and discards into the deck. Press S.">üîÄ</button>
			</div>
			<br/>
		</header>
			
		<div id="drawn"></div>
	
		<div id="shuffled"></div>
		<div id="discarded"></div>
	</div>
</div>


<h1 class="edit_mode">Shuffle</h1>

<div>
	<label for="bg_brightness">BG:</label>
	<input id="bg_brightness" title="Background brightness"
		style="position:relative; top:3px;"
		type="range" min="0" max="100" value="100" steps="100" />
	<button class="play_mode" onclick="show_src(true)" id="edit_button">Edit</button>
</div>

<div class="play_mode">
	<div id="decks_shown"></div>
</div>
<div class="edit_mode">
	<textarea id="src_input" rows=10 cols=50></textarea>
	<br/>
	<span class="fresh"><button id="play_button">Play</button></span>
	<span class="from_edit">
		<button id="load_button">Load</button>
		<button id="resume_button">Resume</button>
	</span><hr/>
	<input id="local_images" type="file" accept="image/*" multiple />
	<button onclick="local_images.value='';" title="Clear files">x</button>
	<p><em>Select files to use with "local:" decks.<br/>
		Clear and re-select to reload changed images.</em></p>
</div>


<!--
#Die
px: 100x100
font:90px Arial
zoom:2
1x 1
1x 2
1x 3
1x 4
1x 5
1x 6
state: -|*|-
-->
<!--
# Helvetica Playing Cards
http://3.bp.blogspot.com/_w_0zEaXF8y8/TT3-sC0g6KI/AAAAAAAAAC0/ff4xXts7bfw/s1600/grid.jpg
grid: 8x7
margin: 38
zoom: 1.2
x0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
-->

<!--
# Aces
http://127.0.0.1:8887/English_pattern_playing_cards_deck.svg.png
grid:13x4
x1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0
state:|0 1 2 3|

# 2s
http://127.0.0.1:8887/English_pattern_playing_cards_deck.svg.png
grid:13x4
x0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0
state:|0 1 2 3|
-->
		
<!--
# TOT: Letters Setup
https://i.imgur.com/YMqN1nf.jpg
grid:1x13
zoom:0.3

# TOT: Sights Setup
https://i.imgur.com/DfBm3o1.png
grid:5x1
zoom:0.3

# TOT: Terrain
https://i.imgur.com/CVdaynk.png
grid:5x1
zoom:0.3
x6 2 7 4 8
-->


<style id="card_style" type="text/css"></style>
<script>
	var CARD_MARGIN = 5;
	
	var prototype = document.getElementById("prototype");
	prototype.parentNode.removeChild(prototype);
	
	prototype.id = "";

	Object.defineProperty(status_display, "value", {
		set: function(v) {
			if (v) {
				status_display.innerText = v;
				status_display.classList.add("shown");
			}
			else {
				status_display.innerText = "";
				status_display.classList.remove("shown");
			}
		}
	});
	
	function to_number(str) { return +str; }
	var find_integers = /\d+/g;
	
	var errors = [];
	function error(message) {
		errors.push(message);
		console.error(message);
	}
	var errors_reported = false;
	errors.report = function() {
		if (errors_reported) { return true; }
		
		if (errors.length > 0) {
			alert("Could not create deck(s) for the following reasons:\n\n"
				  + errors.join("\n"));
			errors_reported = true;
			return true;
		}
	}

	var adding_x_y = {};
	function index_to_x_y(deck, index, out) {
		out.x = (index % deck.gwidth);
		out.y = Math.floor((index - out.x) / deck.gwidth);
		return out;
	}

	function indices_of(nodes) {
		return [...nodes].map(function(c) { return c.dataset.index; });
	}

	var decks = [], deck;
	var decks_row;

	function show_src(editing) {
		if (!editing) {
			document.body.classList.add("is-playing");
		}
		else {
			document.body.classList.remove("is-playing");
		}
	}
	show_src(true);

	function generate_state(deck) {
		var shuffled = deck.shuffled.childNodes.length,
			drawn = deck.drawn.childNodes.length,
			discarded = deck.discarded.childNodes.length;

		if (drawn || discarded) {
			var shuffled_state;
			if (!shuffled) { shuffled_state = "-"; }
			// else if (!drawn && !discarded) { shuffled_state = "*"; }
			else if (shuffled < discarded) {
				shuffled_state = indices_of(deck.shuffled.childNodes).join(" ");
			}
			else { shuffled_state = "?"; }

			var drawn_state;
			if (!drawn) { drawn_state = "-"; }
			else if (!shuffled && !discarded) { drawn_state = "*"; }
			else {
				drawn_state = indices_of(deck.drawn.childNodes).join(" ");
			}

			var discarded_state;
			if (!discarded) { discarded_state = "-"; }
			else if (!shuffled && !drawn) { discarded_state = "*"; }
			else if (discarded <= shuffled) {
				discarded_state = indices_of(deck.discarded.childNodes).join(" ");
			}
			else { discarded_state = "?"; }

			return `\nstate: ${shuffled_state}|${drawn_state}|${discarded_state}`;
		}
		else {
			return "";
		}
	}

	function regen_text_cards(cards) {
		var f = undefined;
		var s = -1;
		var out = "";
		for (var i = 0; i < cards.length; i++) {
			var c = cards[i];
			if (f != c.font) {
				f = c.font;
				out += "\nfont:" + f;
			}
			if (c.style_id !== -1 && s != c.style_id) {
				s = c.style_id;
				out += "\n" + card_styles[c.style_id];
			}
			out += `\n${c.quantity}x ${c.content}`
		}
		return out;
	}
	
	edit_button.onclick = function() {
		document.body.classList.add("edited");
		
		src_input.value = decks.map(function(deck) {
			if (deck.info) {
				return "." + (deck.side ? "<" : "") + " " + deck.html.value.replace(/\r?\n/g, "\\n");
			}
			else {
				return (
					"#" + (deck.side ? "<" : "") + " " +
					(deck.name) +
					(
						deck.local ? "\nlocal: "+deck.local
						: deck.img_url ? "\n" + deck.img_url
						: ""
					) +
					(
						deck.grid ? "\ngrid: " + deck.grid
							: deck.px ? "\npx: " + deck.px
							: ""
					) +
					(
						deck.zoom !== 1 ? "\nzoom: " + deck.zoom : ""
					) +
					(
						(deck.margin.x || deck.margin.y)
							? "\nmargin: " + (
								deck.margin.x === deck.margin.y
									? deck.margin.x
									: deck.margin.x + " " + deck.margin.y
							)
							: ""
					) +
					(
						deck.quantities ? "\nx" + deck.quantities.join(" ") : "" 
					) +
					(
						deck.text_cards ? regen_text_cards(deck.text_cards) : ""
					) +
					(
						generate_state(deck.shown)
					)
				);
			}
		}).join("\n\n");

		show_src(true);
	};

	bg_brightness.oninput = function() {
		var b = bg_brightness.value / 100;
		var h = b * 255;
		document.body.style.backgroundColor = `rgb(${h},${h},${h})`;
		if (b < 0.5) { document.body.classList.add("dark"); }
		else {         document.body.classList.remove("dark"); }
	};
				
	play_button.onclick = play;
	load_button.onclick = play;
	resume_button.onclick = function() {
		show_src(false);
	};

	var played = false;
	function play() {
		if (!played) {
			played = true;
			window.onbeforeunload = function() {
				return "You will lose the current state of the game. Is this okay?";
			};
		}
		
		errors_reported = false;
		errors.length = 0;
		decks.length = 0; deck = null;
		loading_images = {};
		loading_promises.length = 0;
		decks_shown.innerHTML = "";

		var local_images_by_name = {};
		if (local_images.files.length > 0) {
			for (var i = 0; i < local_images.files.length; i++) {
				local_images_by_name[local_images.files[i].name] = local_images.files[i];
			}
		}

		card_styles.use = false;
		card_styles.length = 0;
		src_input.value.replace(scan_src, parse_src);
		if (decks.length === 0) { error("Found no decks."); }
		if (errors.report()) { return; }

		// load images, setup decks
		Promise.all(
			decks.map(function(deck) {
				if (deck.img_url) {
					return new Promise(function(resolve, reject) {
						var img = deck.img = new Image();
						img.onload = resolve;
						img.onerror = function() {
							error(`Could not load image "${deck.img_url}".`);
							reject();
						};
						img.src = deck.img_url;
					});
				}
				else if (deck.local) {
					var deck_local_file = local_images_by_name[deck.local];
					if (deck_local_file) {
						return new Promise(function(resolve, reject) {
							var FR = new FileReader();
							FR.onload = function() {
								deck.img_url = URL.createObjectURL(new Blob([FR.result]),
									{ type: deck_local_file.type });
								deck.img = new Image();
								deck.img.onload = resolve;
								deck.img.src = deck.img_url;
							};
							FR.onerror = function() {
								error(`Could not load local image "${deck_local_file.name}".`);
								reject();
							};
							FR.readAsArrayBuffer(deck_local_file);
						});
					}
					else {
						error(`Local image "${deck.local}" not selected.`);
					}
				}
				else if (!deck.info && !deck.text_cards) {
					error(`No image or text cards defined for deck "${deck.name}".`);
				}
			})
		).then(function then() {
			decks.forEach(setup_deck);
			if (errors.report()) { return; }

			card_styles.setup();
			
			show_src(false);
		}, function do_catch() {
			errors.report();
		});
	};

	var loading_images;
	var loading_promises = [];

	var card_styles = [];
	card_styles.use = false;
	card_styles.setup = function() {
		var css = "";
		for (var i = 0; i < card_styles.length; i++) {
			var s = ` .deck #drawn .card[data-style="${i}"] `;
			var styles = card_styles[i].replace(/(.*?)(\{[^}]*\})/g, function(m,
				selector, style
			) {
				return (
					selector.replace(/\$(?=\s+[^\{])/g, s + " .content ")
						.replace(/\$(?=[\s\{])/g, s) +
					style +
					"\n"
				);
			});
			css += styles;
		}
		card_styles_css.innerHTML = css;
	}
	
	var scan_src = /^\#(<)?[ \t]*(\S.*)$|^x((?:\d+[ \t]*)+)$|^((?:file|https?):.+)$|^(\d+)x[ \t]+(.+)$|^\.(<)?[ \t]*(.+)$|^(\$.*)$|^(\w+):[ \t]*(.+)$/gm;
	function parse_src(m,
		deck_side, name,
		quantities, url,
		text_quantity, text,
		info_side, info,
		styles,
		key, value
	) {
		if (errors.length > 0) { return; }

		if (!deck) {
			if (deck_side) { error("Deck to the side, but no non-side before it."); return; }
			if (info_side) { error("Info to the side, but no non-side before it."); return; }
		}
		if (name) {
			if (deck && !deck.info && !deck.img_url && !deck.text_cards) {
				error("No image defined for deck.");
				return;
			}
			decks.push(deck = { name: name });
			deck.side = deck_side;
			// subsequent text cards shouldn't use a style
			// until a new style is defined within this deck
			card_styles.use = false;
		}
		else if (info) {
			decks.push(deck = { info: info });
			deck.side = info_side;
		}
		else {
			if (!deck) { error(`No name for deck when finding "${m}".`); return; }
			
			if (url) {
				deck.img_url = url;
			}
			else if (quantities) {
				deck.quantities = quantities;
			}
			else if (text_quantity) {
				var q = parseInt(text_quantity);
				if (text) {
					if (!deck.text_cards) { deck.text_cards = []; }
					var sid = card_styles.use ? card_styles.length - 1 : -1;
					deck.text_cards.push({
						quantity:q, font:deck.font,
						style_id: sid,
						content:text
					});
				}
				else {
					error(`Text card has no content.`);
					return;
				}
			}
			else if (styles) {
				card_styles.use = true;
				card_styles.push(styles);
			}
			else if (key) {
				deck[key] = value;
			}
		}
	}


	var last_id = 0;
	function setup_deck(deck) {
		var id = "deck_" + (last_id++);
		
		if (!deck.side) {
			decks_row = decks_shown.appendChild(document.createElement("div"));
			decks_row.className = "row";
		}

		
		if (deck.info) { // info
			var info = decks_row.appendChild(document.createElement("textarea"));
			info.className = "info";
			info.innerHTML = deck.info.replace(/\\n/g, "\n");
			deck.html = info;
			return;
		}

		
		if (errors.report()) { return; }
		
		if (!("zoom" in deck)) { deck.zoom = 1; }
		else { deck.zoom = +deck.zoom; }

		if (!("margin" in deck)) { deck.margin = { x:0, y:0 }; }
		else {
			var m = deck.margin.match(/^(\d+)(?:[ \t]+(\d+))?$/);
			if (!m) {
				error(`Invalid margin: "${deck.margin}".`);
				return;
			}
			else {
				if (m[2]) {
					deck.margin = { x:+m[1], y:+m[2] };
				}
				else {
					deck.margin = { x:+m[1], y:+m[1] };
				}
			}
		}
		
		var p = prototype.cloneNode(true);
		var card = deck.card_prototype = p.children[0];
		card.style.margin = CARD_MARGIN + "px";
		var deck_shown = deck.deck_shown = p.children[1];
		deck.shown = deck_shown;
		deck_shown.id = id;

		var shuffled = deck_shown.shuffled =
			deck_shown.querySelector("#shuffled");
		var shuffled_cards = shuffled.childNodes;
		
		var drawn = deck_shown.drawn =
			deck_shown.querySelector("#drawn");
		var drawn_cards = drawn.childNodes;
		
		var discarded = deck_shown.discarded =
			deck_shown.querySelector("#discarded");
		var discarded_cards = discarded.childNodes;

		deck_shown.draw_button = deck_shown.querySelector("#draw_button");
		deck_shown.draw_all_button = deck_shown.querySelector("#draw_all_button");
		deck_shown.roll_button = deck_shown.querySelector("#roll_button");
		deck_shown.discard_button = deck_shown.querySelector("#discard_button");
		deck_shown.undiscard_button = deck_shown.querySelector("#undiscard_button");
		deck_shown.shuffle_button = deck_shown.querySelector("#shuffle_button");
	
		deck_shown.status_display = deck_shown.querySelector("#status_display");

		
		var status = deck_shown.querySelector("#status_display");
		
		deck_shown.querySelector("#name_display").innerText = deck.name;

		var iwidth = 150, iheight = 210;
		if (deck.img) {
			var iwidth = deck.img.width - (deck.margin.x * 2);
			var iheight = deck.img.height - (deck.margin.y * 2);
		}
		
		if (deck.px) {
			var wh = deck.px.split("x").map(to_number);
			deck.cwidth = wh[0]; deck.cheight = wh[1];
			deck.gwidth = Math.round(iwidth/wh[0]) * wh[0];
			deck.gheight = Math.round(iheight/wh[1]) * wh[1];
		}
		else if (deck.grid) {
			var wh = deck.grid.split("x").map(to_number);
			deck.cwidth = iwidth/wh[0]; deck.cheight = iheight/wh[1];
			deck.gwidth = wh[0]; deck.gheight = wh[1];
		}
		else {
			deck.cwidth = iwidth;
			deck.cheight = iheight;
			deck.gwidth = 1; deck.gheight = 1;
		}
		
		// css
		// card.style.lineHeight = deck.cheight + "px";

		card.style.zoom = deck.zoom;
	
		if (deck.text_cards) {
			card.style.width = deck.cwidth + "px";
			card.style.height = deck.cheight + "px";
		}
		else {
			card.style.width = deck.cwidth + "px";
			card.style.height = deck.cheight + "px";
		}
		
		if (deck.img_url) {
			card.style.backgroundImage = `url("${deck.img_url}")`;
		}
		
		deck_shown.drawn.style.minHeight = ((deck.cheight * deck.zoom) + (CARD_MARGIN * 2)) + "px";
	
		// add cards to shuffled deck
		var q, use_last = false;
		if (!deck.quantities) { q = 1; use_last = true; }
		else {
			deck.quantities = deck.quantities.split(" ").map(to_number);
		}

		
		var i = 0;
		if (deck.img) {
			for (; i < deck.gwidth * deck.gheight; i++) {
				if (!use_last) {
					if (i >= deck.quantities.length) {
						use_last = true;
						q = deck.quantities[deck.quantities.length - 1];
					}
					else {
						q = deck.quantities[i];
					}
				}
	
				if (q > 0) {
					var xy = index_to_x_y(deck, i, adding_x_y);
					var c = deck.card_prototype.cloneNode(true);
					c.dataset.index = i;
					
					c.style.backgroundPosition =
						`${(-deck.margin.x + (-xy.x * deck.cwidth))}px
						 ${(-deck.margin.y + (-xy.y * deck.cheight))}px`;
	
					shuffled.appendChild(c);
					
					for (var j = 1; j < q; j++) {
						shuffled.appendChild(c.cloneNode(true));
					}
				}
			}
		}


		// text cards
		if (deck.text_cards) {
			var offset = i;
			card.style.backgroundImage = "";
			card.className = "card text";
			for (i = 0; i < deck.text_cards.length; i++) {
				var t = deck.text_cards[i];
				var q = t.quantity;
	
				if (q > 0) {
					var c = card.cloneNode(true);
					var content = c.appendChild(document.createElement("div"));
					content.className = "content";
					content.innerHTML = t.content;

					c.dataset.index = offset + i;
					if (t.style_id !== -1) {
						c.dataset.style = t.style_id;
					}
					c.style.font = t.font;

					shuffled.appendChild(c);
				
					for (var j = 1; j < q; j++) {
						shuffled.appendChild(c.cloneNode(true));
					}
				}
			}
		}


		// restore state
		if (deck.state) {
			// debugger;
			var s = deck.state.split("|");

			// discarded has the rest?
			if (s[2] === "?") {
				move_all(shuffled, discarded);
			}
				
			switch(s[0]) { // shuffled state
				case "*": case "?": case "-": break;
				default: 
					move_all(shuffled, discarded);
					move_all_indices(s[0].match(find_integers), discarded, shuffled);
			}

			switch(s[1]) { // drawn state
				case "?": case "-": break;
				case "*": move_all(shuffled, drawn); break;
				default:
					// from deck_shown (from any pile)
					move_all_indices(s[1].match(find_integers), deck_shown, drawn);
			}

			switch(s[2]) { // discarded state
				case "?": case "-": break;
				case "*": move_all(shuffled, discarded); break;
				default:
					move_all_indices(s[2].match(find_integers), shuffled, discarded);
			}
		}


		deck_shown.addEventListener("mouseover", function(e) {
			e.preventDefault();
			e.stopPropagation();

			switch (e.target.id) {
				case "draw_button":
				case "draw_all_button":
				case "roll_button":
					status_display.value = deck_shown.shuffled.childNodes.length + " card(s) to draw";
					break;
				case "discard_button":
					status_display.value = deck_shown.drawn.childNodes.length + " card(s) currently drawn";
					break;
				case "shuffle_button":
					status_display.value = deck_shown.discarded.childNodes.length + " card(s) to shuffle back into the deck";
					break;
			}
		}, true);

		deck_shown.addEventListener("mouseout", function(e) {
			e.preventDefault();
			e.stopPropagation();
			status_display.value = "";
		});
		
		// click handler
		deck_shown.addEventListener("click", function(e) {
			e.preventDefault();
			e.stopPropagation();

			deck_shown.focus();

			if (e.target.classList.contains("card")) {
				discarded.prepend(e.target);
			}
			else { // buttons
				switch (e.target.id) {
					case "draw_button":
						drawn.appendChild(shuffled_cards[shuffled_cards.length * Math.random() | 0]);
						break;

					case "draw_all_button":
						move_all(shuffled, drawn);
						break;

					case "roll_button":
						deck_shown.shuffle_button.click();
						deck_shown.draw_button.click();
						break;

					case "discard_button":
						move_all(drawn, discarded);
						break;

					case "undiscard_button":
						deck_shown.drawn.appendChild(
							deck_shown.discarded.lastElementChild
						);
						break;
					
					case "shuffle_button":
						move_all(discarded, shuffled);
						move_all(drawn, shuffled);
						break;
				}
			}
			
			update_controls(deck_shown);
		}, true);

		deck_shown.addEventListener("keyup", function(e) {
			if (e.shiftKey || e.ctrlKey) { return; }
			
			e.preventDefault();
			e.stopPropagation();
			
			switch(e.key) {
				case "1": case "2": case "3": case "4": case "5":
				case "6": case "7": case "8": case "9":
					for (var i = 0; i < +e.key; i++) {
						deck_shown.draw_button.click();
					}
					break;

				case "0":
					deck_shown.discard_button.click();
					break;

				case "s":
					deck_shown.shuffle_button.click();
					break;

				case "r":
					deck_shown.roll_button.click();
					break;
			}
		});

		update_controls(deck_shown);

		decks_row.appendChild(deck_shown);
	}

	function move_all(from, to) {
		while (from.childNodes.length > 0) {
			to.appendChild(from.childNodes[0]);
		}
	}
	function move_all_indices(indices, from, to) {
		for (var i = 0; i < indices.length; i++) {
			var c = from.querySelector(`.card[data-index="${indices[i]}"]`);
			if (c) { to.appendChild(c); }
			else { console.error(`Could not find card with index ${indices[i]}`); }
		}
	}



	function update_controls(deck_shown) {
		deck_shown.draw_button.disabled =
		deck_shown.draw_all_button.disabled =
			(deck_shown.shuffled.childNodes.length === 0);
		
		deck_shown.discard_button.disabled = 
			(deck_shown.drawn.childNodes.length === 0);
		
		deck_shown.undiscard_button.disabled = 
			(deck_shown.discarded.childNodes.length === 0);
		
		deck_shown.shuffle_button.disabled = 
			(deck_shown.drawn.childNodes.length === 0
			&& deck_shown.discarded.childNodes.length === 0);
	}
	
</script>

<div class="edit_mode" id="explanation">
	<p>Type text into the source box above, 
		and click "Play" to load it.
		Drag the bottom-right corner of the box to adjust its size.
	</p>
	<p>Drag the BG slider at the top of the page
		to adjust how dark/light the page background is.
		This can help to avoid burnout in your screen if the page
		doesn't change for some time.
	</p>
	<p>
		While playing, click "Edit" to return to the source box.
		It will have "state" lines added to the decks to save which cards 
		are where, and notes will reflect any edited text.
		The source can be saved in a text file or message to save the current state, 
		and pasted in to resume playing from that state.
		The source text works as follows:
	</p>
	<p><q>. Notes</q>: An editable note that is displayed 
		between decks.
		While playing, notes can be edited during the game,
		and new lines can be added.
		Drag the bottom-right corner of the note to adjust its size.
	</p>
	<p><q># Name</q>: the name for the deck.
		<q>#&lt; Name</q> will place the deck on the same line as the 
		previous deck or note.
	</p>
	<p><q>http:...</q>, <q>https:...</q>:
		the address of an image to be used for the deck.
		<q>local:...</q> the file name of an image,
		to be selected with the file input below the source box.
		Click the "x" button next to the file input
		to clear it--allowing the images to be reloaded.
	</p>
	<p><q>grid:5x4</q>: how many cards across and how many cards down
		are in the image.
		Or <q>px:200x300</q>: the size in pixels of each card.
		If left out, the entire image will be used as one card.
	</p>
	<p><q>margin:5</q>: the margin to cut out around the entire image.
		Or <q>margin:5 10</q>: the margin for left/right, 
		and then the margin for top/bottom.
	</p>
	<p>
		<q>zoom:1.2</q>: make the cards larger (> 1), or smaller (< 1).
	</p>
	<p><q>x1 2 0 1 1 19 0</q>: the quanitity of each card from the image,
		going top-to-bottom, left-to-right.
		<em>When left out, all cards will be included once.</em>
		If there are more cards in the image that quantities in the list,
		the last quantity will be used for the rest of the cards.
	</p>
	<p>
		<q>$ { background:red; }</q>:
		<a href="https://developer.mozilla.org/en-US/docs/Web/CSS" target="_blank"">CSS styles</a>
		applied to all following cards within this deck
		until another style line is found.
		This is for more advanced deck creators,
		lets you break things, but lets you have much more complex 
		text cards.
	</p>
	<p>
		A style consists of a selector and a declaration.
		In the <q>$ img { border:1px solid red; }</q> code,
		the selector is <q>$ img</q>--selecting any &lt;img> tags
		within a card.
		And the declaration is <q>border:1px solid red;</q>--giving
		the image a red border 1 pixel wide.
		You can select different things at the same time by 
		adding more selectors and commas in between, like this: <q>$ img, $ a {...}</q>.
	</p>
	<p>
		You can add as many such styles in the same line to apply 
		them all to the cards.
		If the code <q>$ { background:green; }</q> was added,
		the card itself would have a green background.
	</p>
	<!--<p><q>font:20px Arial</q>: the font to use for subsequent text cards
		within this deck.
		<em>Note, must include at least the font name.</em>
		See <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font" target="_blank">MDN reference</a> 
		for more details on how to write fonts.
	</p>-->
	<p>
		<q>5x Card text</q>: a text card--starting with the quantity,
		and followed by the contents of the card.
		The cards will have a white background and black text.
		Text cards are added <em>after</em> image cards.
		This can include any text, emojis.
		<em>Search <a href="https://symbl.cc/" target="_blank">Symbl</a> 
		or <a href="https://emojidb.org/" target="_blank">EmojiDB</a>
		to find emoji to use for your cards.</em>
	</p>
	<p>These can also include 
		<a href="https://developer.mozilla.org/en-US/docs/Web/HTML" target="_blank"">HTML tags</a>.
		Here are a few useful tags, but any tags should work.</p>
	<ul>
		<li><q>&lt;br/></q>: new line.</li>
		<li><q>&lt;hr/></q>: horizontal line, good for a border.</li>
		<li><q>&lt;b>text&lt;/b></q>: bold text.</li>
		<li><q>&lt;i>text&lt;/i></q>: italic text.</li>
		<li><q>&lt;u>text&lt;/u></q>: underlined text.</li>
		<li><q>&lt;big>text&lt;/big></q>: extra large, useful for single-icon cards.</li>
		<li><q>&lt;med>text&lt;/med></q>: slightly larger than normal text,
			useful for making an emoji slightly bigger to match the text,
			or headings.</li>
		<li><q>&lt;sml>text&lt;/sml></q>: smaller text.</li>
		<li>Feel free to make up your own tags, and use a 
			<q>$ tag {style}</q> line to define how they look.</li>
	</ul>
	<p><q>state:0 3|?|1 2 4</q>: which cards are in the shuffled deck,
		being shown, and discarded.
		<q>-</q> means no cards are here.
		<q>?</q> means the cards that are not elsewhere are here.
		<q>*</q> means all cards are here.
		<em>You don't have to worry about how this works unless
		you want to write it manually.</em>
	</p>
</div>

	<!--

# Prestige Buildings
px: 300x200
zoom: 0.7
font:18px Arial
$ l { width:140px; float:left; } $ txt { float:right; width:150px; } $ b { display:block; }
1x <l><big>üóø</big><b>Monument</b>ü™®ü™®ü™®</l><txt>2‚≠êx unused ü™®<br/>+4‚≠ê
1x <l><big>üî•</big><b>Pyre</b>ü™µü™µü™µ</l><txt>2‚≠êx unused ü™µ<br/>+4‚≠ê
1x <l><big>üç¥</big><b>Feast</b>üêüüêüüêü</l><txt>Find the üè† farthest away.<br/>2‚≠êx as many üè† are that far away
1x <l><big>üõû</big><b>Cartwright</b>ü™®ü™µü™µ</l><txt>2‚≠êx üè† in one direction from building
1x <l><big>üèõ</big><b>Great Hall</b>ü™®ü™®ü™µ</l><txt>‚≠êx üè† in range 2
1x <l><big>üè°</big><b>Townhouse</b>ü™®üêüüêü</l><txt>2‚≠êx open buildings at range 2
1x <l><big>üï≥Ô∏è</big><b>Well</b>ü™®ü™®üêü</l><txt>‚≠êx distance to closest üåä
1x <l><big>‚õµ</big><b>Shipyard</b>ü™µüêüüêü</l><txt>‚≠êx near + connected üåä<br/>+2‚≠ê
1x <l><big>üõè</big><b>Inn</b>ü™µü™µüêü</l><txt>2‚≠êx near empty spaces
1x <l><big>ü™ô</big><b>Market</b>ü™®ü™µüêü</l><txt>3‚≠êx set of unused resources ü™µü™®üêü in range 3
1x <l><big>üó∫</big><b>Map Maker</b>ü™µü™µ‚ú±</l><txt>‚≠êx <med>‚óã</med>/<med>‚óè</med> in range 3
1x <l><big>üåâ</big><b>Bridge</b>ü™®ü™®‚ú±</l><txt>Opposite sides must non-üåä.<br/>4‚≠êx near water
1x <l><big>üçª</big><b>Pub</b>ü™®ü™µ‚ú±</l><txt>2‚≠êx unused üêü
1x <l><big>üì¶</big><b>Distributor</b>üêüüêü‚ú±</l><txt>‚≠êx near shops x <med>‚óã</med> in range 2
1x <l><big>üçû</big><b>Baker</b>ü™®üêü‚ú±</l><txt>‚≠êx near üè† x üé£ in range 2
1x <l><big>üìö</big><b>School</b>ü™µüêü‚ú±</l><txt>‚≠êx near üè† x üå≥ in range 2
state: -|*|-

	-->
